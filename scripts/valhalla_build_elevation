#!/usr/bin/env python3

import argparse
import logging
import gzip
import json
import sys
import os
from collections import namedtuple
from functools import partial
from math import ceil, floor
from multiprocessing import cpu_count
from multiprocessing.dummy import Pool as ThreadPool
from pathlib import Path
from typing import List, Iterable, Set
from urllib import request

# hack so ArgumentParser can accept negative numbers
# see https://github.com/valhalla/valhalla/issues/3426
for i, arg in enumerate(sys.argv):
  if not len(arg) > 1:
    continue
  if (arg[0] == '-') and arg[1].isdigit():
    sys.argv[i] = ' ' + arg

# set up the logger basics
LOGGER = logging.getLogger(__name__)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter("%(asctime)s %(levelname)5s: %(message)s"))
LOGGER.addHandler(handler)
LOGGER.setLevel(logging.INFO)

parser = argparse.ArgumentParser(description="""Download elevation tiles.""")

method = parser.add_mutually_exclusive_group()
method.add_argument(
  "-g",
  "--from-geojson",
  help="Absolute or relative path to directory with .geojson files used "
  "as input to tile intersection. Requires shapely.",
  type=Path,
)
method.add_argument(
  "-b",
  "--from-bbox",
  help="Bounding box coordinates in the format 'minX,minY,maxX,maxY'.",
  type=str,
)
method.add_argument(
  "-t",
  "--from-tiles",
  help="Only download tiles covered by the Valhalla graph.",
  action="store_true",
  default=False,
)

parser.add_argument(
  "-c",
  "--config",
  help="Absolute or relative path to the Valhalla config JSON.",
  type=Path,
)
parser.add_argument(
  "-f",
  "--force",
  help="Remove all existing elevation tiles before download new ones.",
  action="store_true",
  default=False,
)
parser.add_argument(
  "-p",
  "--parallelism",
  help="Number of processing units to use.",
  type=int,
  default=cpu_count(),
)

group = parser.add_mutually_exclusive_group()
group.add_argument(
  "-d",
  "--decompress",
  help="If set, downloaded files will be decompressed (default: gzip).",
  action="store_true",
)
group.add_argument(
  "-z",
  "--lz4",
  help="If set, downloaded files will be recompressed with LZ4 (requires ~12% more disk space vs gzip). Requires lz4.",
  action="store_true",
)

Tile = namedtuple("Tile", ["name", "dir"])
LOCAL_SIZE = 0.25

def get_tile_info(x: int, y: int) -> Tile:
  hemisphere = "S" if y < 0 else "N"
  dir_name = "%s%02d" % (hemisphere, abs(y))
  tile_name = "%s%02d%s%03d.hgt" % (
    hemisphere,
    abs(y),
    "W" if x < 0 else "E",
    abs(x),
  )

  return Tile(tile_name, dir_name)

def grid_from_bounds(bounds: List[float]) -> List[List[int]]:
  """Creates a regular grid of size 1x1 within specified bounds"""
  # expand bbox by snapping to a 1 x 1 degree grid
  # loop through x and y range and create the grid
  min_x, min_y = [floor(x) for x in bounds[:2]]
  max_x, max_y = [ceil(x) for x in bounds[-2:]]
  for x in range(min_x, max_x):
    for y in range(min_y, max_y):
      yield [x, y, x + 1, y + 1]

def get_tiles_with_geojson(geojson_dir: Path) -> Set[Tile]:
  LOGGER.info(f"Get elevation tiles with GeoJSON directory: {geojson_dir}")

  try:
    from shapely.geometry import Polygon, box
  except ImportError:
    LOGGER.error("Could not import shapely. Please install shapely or use another download method instead.")

    sys.exit(1)

  if not geojson_dir.is_dir() or not len(list(geojson_dir.glob('*.geojson'))) > 0:
    LOGGER.error(f"Geojson directory does not exist or contains no GeoJSON files: {geojson_dir.resolve()}")

    sys.exit(1)

  def get_outer_rings(geojson_dir: Path) -> Iterable[Polygon]:
    for file in geojson_dir.glob("*.geojson"):
      with open(file) as f:
        geojson = json.load(f)
      for feature in geojson["features"]:
        if feature["geometry"]["type"] == "Polygon":
          yield Polygon(feature["geometry"]["coordinates"][0])
        if feature["geometry"]["type"] == "MultiPolygon":
          for single_polygon in feature["geometry"]["coordinates"]:
            yield Polygon(single_polygon[0])

  tile_infos = set()
  for poly in get_outer_rings(geojson_dir):
    for rect in grid_from_bounds(poly.bounds):
      if poly.intersects(box(*rect)):
        tile_x, tile_y, *_ = rect
        tile_infos.add(get_tile_info(tile_x, tile_y))

  return tile_infos

def get_tiles_with_bbox(bbox_str: str) -> Set[Tile]:
  LOGGER.info(f"Get elevation tiles with BBox: {bbox_str}")

  # parse bbox
  try:
    bbox = min_x, min_y, max_x, max_y = [float(x) for x in bbox_str.split(",")]
  except ValueError:
    LOGGER.error(f"BBox {bbox_str} is not a comma-separated string of coordinates.")

    sys.exit(1)

  # validate bbox
  if min_x > max_x or min_x < -180 or max_x > 180 or min_y > max_y or min_y < -90 or max_y > 90:
    LOGGER.error(f"BBox is invalid: {bbox}")

    sys.exit(1)

  tile_infos = set()
  for grid in grid_from_bounds(bbox):
    tile_x, tile_y = grid[:2]
    tile_infos.add(get_tile_info(tile_x, tile_y))

  return tile_infos

def get_tiles_with_graph(graph_dir: Path) -> Set[Tile]:
  LOGGER.info(f"Get elevation tiles with Graph directory: {graph_dir}")

  if not graph_dir.is_dir():
    LOGGER.error(f"Graph directory {graph_dir.resolve()} does not exist.")

    sys.exit(1)

  tile_infos = set()
  local_dir = graph_dir.joinpath('2')
  tile_width = int(360 / LOCAL_SIZE)

  for tile_fp in local_dir.rglob('*.gph'):
    # turn the path into a tile ID
    tile_id = int(str(tile_fp.parent.relative_to(local_dir).joinpath(tile_fp.stem)).replace(os.sep, ''))

    tile_x = floor(int(tile_id % tile_width) * LOCAL_SIZE - 180)
    tile_y = floor(int(tile_id / tile_width) * LOCAL_SIZE - 90)

    tile_infos.add(get_tile_info(tile_x, tile_y))

  return tile_infos

def download_tile(tile: Tile, output_dir) -> bool:
  os.makedirs(f'{output_dir}/{tile.dir}', exist_ok=True)
  
  filepath = Path(f"{output_dir}/{tile.dir}/{tile.name}")
  url = f"https://elevation-tiles-prod.s3.us-east-1.amazonaws.com/skadi/{tile.dir}/{tile.name}.gz"

  try:
    LOGGER.info(f"Downloading elevation tile from {url}...")

    with request.urlopen(url) as res, open(filepath, "wb") as f:
      with gzip.GzipFile(fileobj=res, mode="rb") as gz:
        try:
          uncompressed = gz.read()
        except Exception as e:
          LOGGER.error(f"Failed to decompress elevation tile {tile.dir}/{tile.name}: {e}.")

          return False
        else:
          f.write(uncompressed)
  except Exception as e:
    LOGGER.error(f"Failed to download elevation tile {tile.dir}/{tile.name}: {e}.")

    return False

  return True

def list_tiles(tiles_dir: Path) -> Set[Tile]:
  tiles = set()

  for dir_name in tiles_dir.iterdir():
    if dir_name.is_dir():
      for tile_name in dir_name.iterdir():
        if tile_name.is_file():
          tiles.add(Tile(str(tile_name.name), str(dir_name.name)))
  
  return tiles

if __name__ == "__main__":
  args = parser.parse_args()

  if not args.config:
    LOGGER.error("No valid config file used.")

    sys.exit(1)

  config = None
  with open(args.config) as f:
    config = json.load(f)

  elevation_fp = config["additional_data"].get("elevation")
  if not elevation_fp:
    LOGGER.error("'Can't find valid path for 'additional_data.elevation' in {args.config}.")

    sys.exit(1)

  if args.from_geojson:
    tiles = get_tiles_with_geojson(args.from_geojson)
  elif args.from_bbox:
    tiles = get_tiles_with_bbox(args.from_bbox)
  elif args.from_tiles:
    tiles = get_tiles_with_graph(Path(config["mjolnir"]["tile_dir"]))
  else:
    LOGGER.error("No download method specified.")

    sys.exit(1)

  LOGGER.info(f"Found {len(tiles)} matching tiles: {tiles}.")

  if not args.force:
    existing_tiles = list_tiles(Path(elevation_fp))
    other_tiles = [tile for tile in tiles if tile not in existing_tiles]

    LOGGER.info(f"Found {len(existing_tiles)} existing tiles: {existing_tiles}.")

    if len(other_tiles):
      LOGGER.error(f"Missing {len(other_tiles)} elevation tiles: {other_tiles}.")

      sys.exit(1) 
  else:
    results = ThreadPool(args.parallelism).imap_unordered(
      partial(download_tile, output_dir=Path(elevation_fp)),
      tiles,
    )

    downloaded = list(filter(lambda res: res is True, results))
    
    LOGGER.info(f"Downloaded {len(downloaded)} elevation tiles.")
