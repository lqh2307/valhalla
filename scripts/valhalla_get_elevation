#!/usr/bin/env python3

from multiprocessing.dummy import Pool as ThreadPool
from multiprocessing import cpu_count
from collections import namedtuple
from functools import partial
from typing import List, Set
from math import ceil, floor
from urllib import request
from pathlib import Path
import argparse
import logging
import signal
import gzip
import sys
import os

# hack so ArgumentParser can accept negative numbers
# see https://github.com/valhalla/valhalla/issues/3426
for i, arg in enumerate(sys.argv):
  if not len(arg) > 1:
    continue
  if (arg[0] == '-') and arg[1].isdigit():
    sys.argv[i] = ' ' + arg

# Config logs
LOGGER = logging.getLogger(__name__)
handler = logging.StreamHandler()
handler.setFormatter(logging.Formatter("%(asctime)s %(levelname)5s: %(message)s"))
LOGGER.addHandler(handler)
LOGGER.setLevel(logging.INFO)

# Config args
parser = argparse.ArgumentParser(
  description="""Script to download elevation tiles""",
)

method = parser.add_mutually_exclusive_group()

method.add_argument(
  "--from-bbox",
  help="Only download tiles covered by bounding box coordinates in the format 'minX,minY,maxX,maxY'",
  type=str,
)
method.add_argument(
  "--from-tiles",
  help="Only download tiles covered by the Valhalla graph",
  action="store_true",
  default=False,
)

parser.add_argument(
  "--prefix",
  help="Prefix of path to the data folders",
  type=Path,
  default="data",
)
parser.add_argument(
  "--force",
  help="Force delete existing elevation tiles and redownload",
  action="store_true",
  default=False,
)

Tile = namedtuple("Tile", ["name", "dir"])
LOCAL_SIZE = 0.25

def get_tile_info(x: int, y: int) -> Tile:
  hemisphere = "S" if y < 0 else "N"
  dir_name = "%s%02d" % (hemisphere, abs(y))
  tile_name = "%s%02d%s%03d.hgt" % (
    hemisphere,
    abs(y),
    "W" if x < 0 else "E",
    abs(x),
  )

  return Tile(tile_name, dir_name)

def get_tiles_with_bbox(bbox_str: str) -> Set[Tile]:
  def grid_from_bounds(bounds: List[float]) -> List[List[int]]:
    """Creates a regular grid of size 1x1 within specified bounds"""
    # expand bbox by snapping to a 1 x 1 degree grid
    # loop through x and y range and create the grid
    min_x, min_y = [floor(x) for x in bounds[:2]]
    max_x, max_y = [ceil(x) for x in bounds[-2:]]
    for x in range(min_x, max_x):
      for y in range(min_y, max_y):
        yield [x, y, x + 1, y + 1]

  LOGGER.info(f"Get elevation tiles with BBox: {bbox_str}")

  # parse bbox
  try:
    bbox = min_x, min_y, max_x, max_y = [float(x) for x in bbox_str.split(",")]
  except ValueError:
    LOGGER.error(f"BBox {bbox_str} is not a comma-separated string of coordinates")

    sys.exit(1)

  # validate bbox
  if min_x > max_x or min_x < -180 or max_x > 180 or min_y > max_y or min_y < -90 or max_y > 90:
    LOGGER.error(f"BBox is invalid: {bbox}")

    sys.exit(1)

  tile_infos = set()
  for grid in grid_from_bounds(bbox):
    tile_x, tile_y = grid[:2]
    tile_infos.add(get_tile_info(tile_x, tile_y))

  return tile_infos

def get_tiles_with_graph(graph_dir: Path) -> Set[Tile]:
  LOGGER.info(f"Get elevation tiles with Graph directory: {graph_dir}")

  if not graph_dir.is_dir():
    LOGGER.error(f"Graph directory {graph_dir.resolve()} does not exist")

    sys.exit(1)

  tile_infos = set()
  local_dir = graph_dir.joinpath('2')
  tile_width = int(360 / LOCAL_SIZE)

  for tile_fp in local_dir.rglob('*.gph'):
    # turn the path into a tile ID
    tile_id = int(str(tile_fp.parent.relative_to(local_dir).joinpath(tile_fp.stem)).replace(os.sep, ''))

    tile_x = floor(int(tile_id % tile_width) * LOCAL_SIZE - 180)
    tile_y = floor(int(tile_id / tile_width) * LOCAL_SIZE - 90)

    tile_infos.add(get_tile_info(tile_x, tile_y))

  return tile_infos

def download_tile(tile: Tile, output_dir: Path) -> bool:
  try:
    url = f"https://elevation-tiles-prod.s3.us-east-1.amazonaws.com/skadi/{tile.dir}/{tile.name}.gz"

    LOGGER.info(f"Downloading elevation tile from {url}...")

    Path(f"{output_dir}/{tile.dir}").mkdir(parents=True, exist_ok=True)

    with request.urlopen(url) as res, open(Path(f"{output_dir}/{tile.dir}/{tile.name}"), "wb") as f:
      with gzip.GzipFile(fileobj=res, mode="rb") as gz:
        try:
          uncompressed = gz.read()
        except Exception as e:
          LOGGER.error(f"Failed to decompress elevation tile {tile.dir}/{tile.name}: {e}")

          return False
        else:
          f.write(uncompressed)
  except Exception as e:
    LOGGER.error(f"Failed to downloading elevation tile {tile.dir}/{tile.name}: {e}")

    return False

  return True

def list_tiles(tiles_dir: Path) -> Set[Tile]:
  tiles = set()

  for dir_name in tiles_dir.iterdir():
    if dir_name.is_dir():
      for tile_name in dir_name.iterdir():
        if tile_name.is_file():
          tiles.add(Tile(str(tile_name.name), str(dir_name.name)))
  
  return tiles


if __name__ == "__main__":
  signal.signal(signal.SIGINT, lambda sig, frame: (
    LOGGER.info('Received "SIGINT" signal. Exitting...'),

    sys.exit(0)
  ))

  signal.signal(signal.SIGTERM, lambda sig, frame: (
    LOGGER.info('Received "SIGTERM" signal. Exitting...'),

    sys.exit(0)
  ))

  args = parser.parse_args()

  elevation_tiles_dir_path = Path(f"{args.prefix}/elevation_tiles")

  if args.from_bbox:
    tiles = get_tiles_with_bbox(args.from_bbox)
  elif args.from_tiles:
    tiles = get_tiles_with_graph(Path(f"{args.prefix}/tiles"))
  else:
    LOGGER.error("No download method specified")

    sys.exit(1)

  LOGGER.info(f"Found {len(tiles)} matching tiles: {tiles}")

  if not args.force:
    existing_tiles = list_tiles(elevation_tiles_dir_path)

    LOGGER.info(f"Found {len(existing_tiles)} existing tiles: {existing_tiles}")

    other_tiles = [tile for tile in tiles if tile not in existing_tiles]
    if len(other_tiles):
      LOGGER.error(f"Missing {len(other_tiles)} elevation tiles: {other_tiles}")

      sys.exit(1) 
  else:
    results = ThreadPool(cpu_count()).imap_unordered(
      partial(download_tile, output_dir=elevation_tiles_dir_path),
      tiles,
    )

    downloaded = list(filter(lambda res: res is True, results))

    LOGGER.info(f"Finished to downloading {len(downloaded)} elevation tiles")
